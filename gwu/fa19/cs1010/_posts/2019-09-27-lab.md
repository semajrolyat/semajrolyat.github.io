---
layout: post
title:  "Basic Data Analysis"
date:   2019-09-27 00:00:00 -0400
schedule:   2019-09-27 00:00:00 -0400
categories: [GWU]
docclass: "lab"
gwclass: "cs1010"
term: "fa19"
---
<head>
  <link href="/css/syntax.css" rel="stylesheet">
</head>

# Lab 2 - Basic Data Analysis

## Introduction

This week we will work with the ```numpy``` and ```matplotlib``` modules.  These modules are included in a number of Python libraries and are widely used by an even broader set of Python libraries to manipulate, parameterize, and visualize data.  

The ```numpy``` module contains a powerful set of tools that allow us to manipulate large sets of data using a small set of statements.  The goal of ```numpy``` is to model data manipulation operations that can be found in other mathematical programming environments like MatLab, and some of the ```numpy``` syntax and functions are inspired by established MatLab approaches to make transition easier; however, there are some significant differences between the two that prohibit direct translation from Python to MatLab and vice-versa.

The ```matplotlib``` module contains a number of plotting functions that allow data to be visualized using a variety of plotting approaches, _e.g._ line plot, scatter plot, histogram, etc.  ```matplotlib``` can accept the data stored in ```numpy``` data structures, so these two libraries typically work hand-in-hand.

## Scenario

Let's motivate exploration of these modules using the basic data analysis problem of computing grades for a fictional class.  In this fictional class, the overall grade is calculated based on a number of quizzes, homework exercises, and exams.  In the syllabus, the weighting is breakdown is stated to be:
* quizzes are 25% of the overall grade
* homework is 35% of the overall grade
* exams are 40% of the overall grade.

In a surprise and controversial move, the grades have been made public to the class but the student information has been anonymized so that any identifying information individual for students has been stripped from the data.

> This is a peek into how grading might be carried out.  Grading may be applied differently depending on curriculum and standards.  Grading data for an entire class will generally not be made public for a variety of reasons such as privacy concerns.

With the final exam coming up, you are concerned with what your overall grade will be in the class.  You know that you can use Python to help analyze the data, so you download the class grades and try to assess where you stand.

### Data

Create a folder for this lab on your computer.  Download the [data.txt]({{ "/gwu/fa19/cs1010/assets/lab2/data.txt" | absolute_url }}) file and copy it to your lab folder.

There are a total of 50 students in the class and the data in the file is organized as follows:
* columns 1-10 are the quiz grades
* columns 11-15 are the homework grades
* columns 16 is the midterm exam grade

## Data Analysis

There is no one sized fits all solution to data analysis and the process is data and domain driven.  Many fields have developed there own metrics, _i.e._ ways to quantify performance, and these metrics do not necessarily transfer from one field to another.  Throughout your undergraduate studies, you will be exposed to a number of different metrics and approaches to data analysis, and you should be careful when attempting to draw conclusions from an analysis as there are a variety of ways to abuse data and approaches which may result in invalid conclusions.

To perform data analysis, we typically need to examine a set of quantified data, perform some computations on the data, and visualize the data possibly using statistical tools or applying the problem to a different but related domain.  This process generally prescribes the following steps:
1. Read in data
2. Perform computations
3. Generate output

We will use ```numpy``` to perform bulk calculations on the data set and we will use ```matplotlib``` to generate output in the form of plots that we may interpret.  ```numpy``` also allows us to read in data using an simple set of functions, so we can rely on two modules to facilitate the whole of the data analysis process.

## ```numpy``` Basics

Just like last week, we need to use external modules to increase the capabilities available to us in Python.  While the ```turtle``` module allowed us to draw simple diagrams, the ```numpy``` module will allow us to perform bulk operations on large multidimensional arrays of data.  In order to use ```numpy```, we first need to import the module.  

> Generally, we import all modules that we will use in a Python program at the top of the file so that the modules are available all throughout the file.

At the beginning of your program include the following ```import``` statement:

```Python
import numpy as np
```

This statement both enables ```numpy``` to be used in the script and _**aliases**_ ```numpy``` using a shorthand notation ```np```.  We don't have to include the ```as np``` statement, but you will find that this is commonly done mostly for the sake of brevity.

### Reading Data from a File

The data for this scenario has been published in a file.  We wish to avoid hard-coding data directly into a program because data is transient.  Instead, we will typically design a generalized program that can read a file with a particular structure so that when the data changes, it is easy to run a new analysis by simply running the program again.

> Divorcing data from the code is especially important in compiled programs like those produced by Java or C/C++.

Reading data from a file can be quite complicated in many languages and even Python has very fundamental (and challenging to understand) read and write utilities; however, ```numpy``` provides some very simple tools for loading data from a file stored on the local hard-drive.  In order to load a structured data file into memory using ```numpy``` we can simply use the ```loadtxt``` function.

> Comprehensive documentation for ```loadtxt``` is found at [https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)

In order to load the grade data file, we use the following instruction:
```Python
grades = np.loadtxt("data.txt")
```

The above code loads the data stored in ```data.txt``` into a variable named ```grades```.  ```grades``` will be of the ```numpy.ndarray``` type which we will just call an array.

> ```loadtxt``` only works on structured numeric data and the default parameters assume that the fields are delimited by spaces.  ```loadtxt``` is not able to load any type of data file, and is explicitly provided to easily load data that is simple, consistently structured raw numeric data.  For more complex file structures, you will need to dive into the interfaces for [Python file I/O](https://docs.python.org/3/tutorial/inputoutput.html)

> ```numpy``` has a companion function to ```loadtxt``` called ```savetxt``` which allows you to easily save structured numeric data from ```numpy``` array into a data file which will be compatible with ```loadtxt```.  Comprehensive documentation for ```savetxt``` is found at [https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html)

### ```numpy``` Arrays
An array is a structured set of n-dimensional data.  Most languages offer some means to store, structure, and access large amounts of data with like types in memory.  Sometimes this data has only one dimension like a simple list, sometimes this data has two dimensions which we might think of a table consisting of rows and columns, and sometimes this data has higher dimensionality like image data (3-dimensions) or other more sophisticated data representations.

Each element in the array has a combination of one or more _**indices**_ that define the element's storage location and enable direct access to that location.  In a one dimensional array, there is one index into the storage location.  To illustrate this, consider the following Python program:

```python
import numpy as np

a = np.arange(100,200,10)

print(a)

print(a[0])
print(a[4])
print(a[9])
```
The above program produces the following output
```
[100 110 120 130 140 150 160 170 180 190]
100
140
190
```
> The ```numpy.arange``` function generates an array where the first parameter defines the start value, the second parameter defines where to stop (not inclusive), and the third parameter defines the step.  In the above example, the sequence starts at 100, stops _before_ 200, and there is a 10 unit step between each element.  This is the same interface used by the ```range``` function we used with ```for``` loops last week.

The ```print(a)``` statement prints the contents of the array generated by the ```numpy.arange``` function and referenced by the variable ```a```.

The subsequent ```print``` statements access individual elements in the array based on their index within the array.  Python uses square brackets as array operators which instructs Python to access to _element at_ the indices inside the square brackets.

![1 Dimensional Array Indexing]({{ "/gwu/fa19/cs1010/assets/lab2/array1d.png" | absolute_url }})


### Slicing

## ```matplotlib``` Basics

### Line Plots
Maybe sine/cosine data

### Scatter Plots


### Histograms

## Exercise 1

High grade 8th student.

## Exercise 2

## Exercise 3
